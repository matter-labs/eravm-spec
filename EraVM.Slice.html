<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>EraVM.Slice</title>

  <script defer=""
  src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library EraVM.Slice</h1>

<div class="code">
<span class="id" title="keyword">From</span> <span class="id" title="var">RecordUpdate</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">RecordSet</span>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <a class="idref" href="EraVM.Pointer.html#"><span class="id" title="library">Pointer</span></a> <a class="idref" href="EraVM.TransientMemory.html#"><span class="id" title="library">TransientMemory</span></a> <span class="id" title="library">lib.PMap_ext</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a id="Slices" class="idref" href="#Slices"><span class="id" title="section">Slices</span></a>.<br/>
<span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.18+alpha/stdlib//Coq.Bool.Bool.html#"><span class="id" title="module">Bool</span></a> <a class="idref" href="EraVM.Core.html#"><span class="id" title="module">Core</span></a> <a class="idref" href="EraVM.Common.html#"><span class="id" title="module">Common</span></a> <a class="idref" href="EraVM.MemoryBase.html#"><span class="id" title="module">MemoryBase</span></a> <span class="id" title="module">RecordSetNotations</span> <a class="idref" href="EraVM.Pointer.html#"><span class="id" title="module">Pointer</span></a> <a class="idref" href="EraVM.TransientMemory.html#"><span class="id" title="module">TransientMemory</span></a> <span class="id" title="module">PMap_ext</span>.<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">ZMod_scope</span>.<br/>
</div>

<div class="doc"><h1 id="slice">Slice</h1>
<p>Data slice is a virtual memory page holding a read-only fragment of a
<span
class="inlinecode"><a class="idref" href="EraVM.memory.PageTypes.html#data_page"><span
class="id" title="definition">data_page</span></a></span>.</p>
<p>Accesses through a fat pointer should be in bounds of its span.
However, loads by fat pointer return words, not individual bytes, so it
is important to cut off parts of the memory page outside the pointer’s
span.</p>
<p>For example, suppose <span class="math inline">P</span> is a fat
pointer <span class="math inline">(page, 0, 33, 10)</span>. Reading
32-byte <span
class="inlinecode"><a class="idref" href="EraVM.Core.html#word"><span
class="id" title="definition">word</span></a></span> yields bytes from
the offset 10-th to 42-th (excluded). However, the span of <span
class="math inline">P</span> is <span class="math inline">[0,33)</span>
so the bytes from 33-th to 42-th are outside of this span. EraVM treats
the bytes outside <span class="math inline">P</span>’s span as if they
were zeros.</p>
<p>More generally, suppose <span class="math inline">P:=(\mathit{page,
start, length, offset})</span> is a fat pointer. Accesses through <span
class="inlinecode"><a class="idref" href="EraVM.isa.GeneratedMachISA.html#OpLoadPtr"><span
class="id" title="constructor">OpLoadPtr</span></a></span> and <span
class="inlinecode"><span class="id"
title="var">OpLoadPtrInc</span></span> return 32-byte words starting at
an address <span class="math inline">\mathit{start + offset}</span>.</p>
<p>However, a 32-byte <span
class="inlinecode"><a class="idref" href="EraVM.Core.html#word"><span
class="id" title="definition">word</span></a></span> spans across
addresses in range <span class="math inline">[\mathit{start + offset,
start + offset + 32})</span> and therefore can surpass the upper bound
<span class="math inline">\mathit{start + length})</span> if <span
class="math inline">\mathit{length-offset} \leq 32</span>.</p>
<p>Reading past <span class="math inline">\mathit{start+offset}</span>
yields zero bytes. In other words, attempting to read a word that spans
across the pointer bound <span class="math inline">\mathit{start +
offset}</span> will return zero bytes for the addresses <span
class="math inline">[\mathit{start+length, start+offset+32})</span>.</p>
</div>
<div class="code">
<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="data_page_slice_params" class="idref" href="#data_page_slice_params"><span class="id" title="definition">data_page_slice_params</span></a> := <a class="idref" href="EraVM.memory.PageTypes.html#data_page_params"><span class="id" title="definition">data_page_params</span></a> <span class="id" title="notation"><|</span> <a class="idref" href="EraVM.MemoryBase.html#writable"><span class="id" title="projection">writable</span></a> <span class="id" title="notation">:=</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.18+alpha/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> <span class="id" title="notation">|></span>.<br/>
<span class="id" title="keyword">Definition</span> <a id="data_slice" class="idref" href="#data_slice"><span class="id" title="definition">data_slice</span></a> := <a class="idref" href="EraVM.MemoryBase.html#mem_parameterized"><span class="id" title="record">mem_parameterized</span></a> <a class="idref" href="EraVM.Slice.html#data_page_slice_params"><span class="id" title="definition">data_page_slice_params</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="do_slice_page" class="idref" href="#do_slice_page"><span class="id" title="definition">do_slice_page</span></a> (<a id="from_incl:1" class="idref" href="#from_incl:1"><span class="id" title="binder">from_incl</span></a> <a id="to_excl:2" class="idref" href="#to_excl:2"><span class="id" title="binder">to_excl</span></a>: <a class="idref" href="EraVM.memory.PageTypes.html#mem_address"><span class="id" title="definition">mem_address</span></a>) (<a id="m:3" class="idref" href="#m:3"><span class="id" title="binder">m</span></a>:<a class="idref" href="EraVM.memory.PageTypes.html#data_page"><span class="id" title="definition">data_page</span></a>) : <a class="idref" href="EraVM.Slice.html#data_slice"><span class="id" title="definition">data_slice</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <a id="from_key:4" class="idref" href="#from_key:4"><span class="id" title="binder">from_key</span></a> := <a class="idref" href="EraVM.MemoryBase.html#addr_to_key"><span class="id" title="definition">MemoryBase.addr_to_key</span></a> <span class="id" title="var">_</span> <a class="idref" href="EraVM.Slice.html#from_incl:1"><span class="id" title="variable">from_incl</span></a> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <a id="to_key:5" class="idref" href="#to_key:5"><span class="id" title="binder">to_key</span></a> := <a class="idref" href="EraVM.MemoryBase.html#addr_to_key"><span class="id" title="definition">MemoryBase.addr_to_key</span></a> <span class="id" title="var">_</span> <a class="idref" href="EraVM.Slice.html#to_excl:2"><span class="id" title="variable">to_excl</span></a> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <a id="contents:6" class="idref" href="#contents:6"><span class="id" title="binder">contents</span></a> := <span class="id" title="definition">pmap_slice</span> <a class="idref" href="EraVM.Slice.html#m:3"><span class="id" title="variable">m</span></a> <a class="idref" href="EraVM.Slice.html#from_key:4"><span class="id" title="variable">from_key</span></a> <a class="idref" href="EraVM.Slice.html#to_key:5"><span class="id" title="variable">to_key</span></a> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;<a class="idref" href="EraVM.MemoryBase.html#mk_mem"><span class="id" title="constructor">mk_mem</span></a> <a class="idref" href="EraVM.Slice.html#data_page_slice_params"><span class="id" title="definition">data_page_slice_params</span></a> <a class="idref" href="EraVM.Slice.html#contents:6"><span class="id" title="variable">contents</span></a>.<br/>

<br/>
</div>

<div class="doc"><p>Predicate <span
class="inlinecode"><a class="idref" href="EraVM.Slice.html#slice_page"><span
class="id" title="inductive">slice_page</span></a></span> describes a
slice visible to a fat pointer.</p>
</div>
<div class="code">
<br/>
<span class="id" title="keyword">Inductive</span> <a id="slice_page" class="idref" href="#slice_page"><span class="id" title="inductive">slice_page</span></a> (<a id="m:7" class="idref" href="#m:7"><span class="id" title="binder">m</span></a>:<a class="idref" href="EraVM.memory.PageTypes.html#data_page"><span class="id" title="definition">data_page</span></a>) : <a class="idref" href="EraVM.Pointer.html#span"><span class="id" title="record">span</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.18+alpha/stdlib//Coq.Init.Logic.html#::type_scope:x_'->'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="EraVM.Slice.html#data_slice"><span class="id" title="definition">data_slice</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.18+alpha/stdlib//Coq.Init.Logic.html#::type_scope:x_'->'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
| <a id="sfp_apply" class="idref" href="#sfp_apply"><span class="id" title="constructor">sfp_apply</span></a>:<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a id="start:10" class="idref" href="#start:10"><span class="id" title="binder">start</span></a> <a id="length:11" class="idref" href="#length:11"><span class="id" title="binder">length</span></a> <a id="upper_bound:12" class="idref" href="#upper_bound:12"><span class="id" title="binder">upper_bound</span></a> <a id="readonly_slice:13" class="idref" href="#readonly_slice:13"><span class="id" title="binder">readonly_slice</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="EraVM.Slice.html#start:10"><span class="id" title="variable">start</span></a> <a class="idref" href="EraVM.Arith.html#7d9ad0405e299fff5d06f96450066fc0"><span class="id" title="notation">+</span></a> <a class="idref" href="EraVM.Slice.html#length:11"><span class="id" title="variable">length</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.18+alpha/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.18+alpha/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.18+alpha/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.18+alpha/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="EraVM.Slice.html#upper_bound:12"><span class="id" title="variable">upper_bound</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.18+alpha/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.18+alpha/stdlib//Coq.Init.Logic.html#::type_scope:x_'->'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="EraVM.Slice.html#do_slice_page"><span class="id" title="definition">do_slice_page</span></a> <a class="idref" href="EraVM.Slice.html#start:10"><span class="id" title="variable">start</span></a> <a class="idref" href="EraVM.Slice.html#upper_bound:12"><span class="id" title="variable">upper_bound</span></a>  <a class="idref" href="EraVM.Slice.html#m:7"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.18+alpha/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="EraVM.Slice.html#readonly_slice:13"><span class="id" title="variable">readonly_slice</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.18+alpha/stdlib//Coq.Init.Logic.html#::type_scope:x_'->'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="EraVM.Slice.html#slice_page:8"><span class="id" title="inductive">slice_page</span></a> <a class="idref" href="EraVM.Slice.html#m:7"><span class="id" title="variable">m</span></a> (<a class="idref" href="EraVM.Pointer.html#mk_span"><span class="id" title="constructor">mk_span</span></a> <a class="idref" href="EraVM.Slice.html#start:10"><span class="id" title="variable">start</span></a> <a class="idref" href="EraVM.Slice.html#length:11"><span class="id" title="variable">length</span></a>) <a class="idref" href="EraVM.Slice.html#readonly_slice:13"><span class="id" title="variable">readonly_slice</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="EraVM.Slice.html#Slices"><span class="id" title="section">Slices</span></a>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>